#!/usr/bin/bash

# shellcheck source=./config
source "$(dirname "$(realpath "$0")")"/../etc/token_mgmt/config

TOKEN_MANAGEMENT="$(dirname "$(realpath "$0")")"/../etc/token_mgmt/
TOKEN="$TOKEN_MANAGEMENT/.token"
PROFILES="$(for i in "$TOKEN_MANAGEMENT"/profiles/*.tar; do echo -n "$(basename "$i" .tar) "; done )none"

umask 0277

function lock() {
    chmod 500 "$TOKEN_MANAGEMENT"/keys
    chmod 400 "$TOKEN_MANAGEMENT"/keys/*
}

function unlock() {
    chmod 700 "$TOKEN_MANAGEMENT"/keys
    chmod 600 "$TOKEN_MANAGEMENT"/keys/*
}

function usage() {
    echo "$0 command parameters

Commands:

  create [-p] [-w] ${PROFILES// /|}

    Create a new token.

    If there is no active token in the list, new disk keys are created.
    Otherwise, the keys from the currently loaded token are used.

    -p   Create partition.

    -w   Wipe the device before writing the token.

  disable [-f] <token>

    Disable a token. This cannot be undone.

    -f   Do not request confirmation.

  list [-a]

    List active tokens.

    -a   List all tokens.

  load [-l]
 
    Load the token (decrypt disks and activate custom configuration).

    -l   Load only (don't mount the overlays or decrypt the disks).

  getkey ${DISKS// /|}

    Print the key for the disk to the standard output. 
    The key is retrieved from the currently loaded token.

Getting started:

  1) Create the first token:     $0 create none
  2) Load the token:             $0 load -l
  3) Retrieve the disk keys to
     encrypt the disks:          <encryption_command> --key-file <""( $0 getkey DISK )
  4) Create additional tokens 
     for safety.

CAREFUL! IF YOU LOSE ALL ACTIVE TOKENS OR THEIR ASSOCIATED KEYS, 
THE DISK KEYS ARE LOST FOREVER!
" 
}

if [ "$1" == "" ]; then
    usage
    exit 1
fi

while [ "$1" != "" ]; do
    command="$1"; shift
    case "$command" in

        #############################################################
        # create
        #############################################################
        create)
        ;;

        #############################################################
        # disable
        #############################################################
        disable)
            function disable_usage() {
                echo "Usage: $0 $command [-f] <token>" >&2
            }

            force=
            if [ "$1" = "-f" ]; then
                force=y; shift
            fi
            uuid="$(basename "$1" .pem)"; shift

            if [ "$uuid" = "" -o "$1" != "" ]; then
                disable_usage
                exit 1
            fi
            
            if [ ! -f "$TOKEN_MANAGEMENT/keys/$uuid.pem" ]; then
                echo "Token not found." >&2
                exit 1
            fi

            if [ "$force" = "" ]; then
                echo "Disabing a token will render it useless and cannot be undone." >&2
                echo "If you are sure, please confirm with:">&2
                echo >&2
                echo "    $0 $command -f $uuid">&2
                echo >&2
                exit 1
            else
                count="$("$0" list | tail -n-1 | grep -v "$uuid" | wc -l)"
                if [ "$count" = "0" ]; then
                    echo "You cannot disable the last active token. Create another first." >&2
                    exit 1
                else
                    unlock && echo "$(head -n1 "$TOKEN_MANAGEMENT/keys/$uuid.pem")disabled: $(date)" > "$TOKEN_MANAGEMENT/keys/$uuid.pem-disabled" && rm -f "$TOKEN_MANAGEMENT/keys/$uuid.pem" && lock
                fi
            fi
        ;;

        #############################################################
        # list
        #############################################################
        list)
            function list_usage() {
                echo "Usage: $0 $command">&2
            }
            
            if [ "$1" = "-a" ]; then
                match="*.pem*"; shift
            elif [ "$1" = "" ]; then
                match="*.pem"
            else
                list_usage
                exit 1
            fi
            {
                loadeduuid="$(cat "$TOKEN"/ID)"
                echo -e "\033[4mUUID|PROFILE|DESCRIPTION|CREATED|STATUS\033[0m"
                for i in "$TOKEN_MANAGEMENT/keys"/$match; do
                    if [ -f "$i" ]; then
                        uuid="$(basename "$(basename "$i" .pem)" .pem-disabled)"
                        st="\033[0m"
                        status=
                        if [ "$loadeduuid" == "$uuid" ]; then
                            st="\033[3m"
                            status="loaded"
                        fi
                        
                        echo -e "$st$uuid|$(head -n 1 "$i")$status\033[0m"
                    fi
                done
            } | column -s '|' -t
            ;;
        
        #############################################################
        # load
        #############################################################
        load)
        ;;

        #############################################################
        # getkey
        #############################################################
        getkey)
            function getkey_usage() {
                echo "Usage: $0 $command ${DISKS// /|}" >&2
            }
            
            disk="$1"; shift
            if [ "$disk" = "" ]; then
                getkey_usage
                exit 1
            fi
            
            for d in $DISKS; do
                if [ "$d" = "$disk" ]; then
                    if [ ! -f "$TOKEN"/key.enc ]; then
                        echo "No token loaded." >&2
                        exit 1
                    fi
                    openssl enc -d -aes-256-cbc -iter 10 -in "$TOKEN/$disk".enc -out /dev/stdout -pass \
                            file:<(openssl rsautl -decrypt -inkey "$TOKEN_MANAGEMENT/keys/$(cat "$TOKEN"/ID).pem" -in "$TOKEN"/key.enc -out /dev/stdout) \
                        || exit 1
                    exit 0
                fi
            done
            getkey_usage
            exit 1
            ;;
        *)
            echo "Unknown command." >&2
            exit 1
    esac
done
